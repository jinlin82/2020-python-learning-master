\documentclass[ignorenonframetext,11pt,xcolor=dvipsnames,hyperref={colorlinks,allcolors=.,urlcolor=blue, citecolor=violet, bookmarksdepth=4},aspectratio=1610]{beamer}
\setbeamertemplate{caption}[numbered]
\setbeamertemplate{caption label separator}{: }
\setbeamercolor{caption name}{fg=normal text.fg}
\beamertemplatenavigationsymbolsempty
\newcommand\hmmax{0} %% 防止Too many math alphabets used in version normal.
\newcommand\bmmax{0} %% 防止Too many math alphabets used in version normal.
\usepackage{lmodern,bm}   % 必需出现在amsmath等包前面，否则会出错
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Ligatures=TeX,Scale=MatchLowercase}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}

%\newif\ifbibliography

%%\usepackage{natbib}
%\bibliographystyle{plainnat}
%
%
\hypersetup{
            pdftitle={Numpy 用法},
            pdfauthor={Jin},
            pdfborder={0 0 0},
            breaklinks=true}
\urlstyle{same}  % don't use monospace font for urls
\usepackage{longtable,booktabs}
\usepackage{caption}
% These lines are needed to make table captions work with longtable:
\makeatletter
\def\fnum@table{\tablename~\thetable}
\makeatother

% Prevent slide breaks in the middle of a paragraph:
\widowpenalties 1 10000
\raggedbottom

\AtBeginPart{
  \let\insertpartnumber\relax
  \let\partname\relax
  \frame{\partpage}
}
\AtBeginSection{
  \ifbibliography
  \else
    \let\insertsectionnumber\relax
    \let\sectionname\relax
    \frame{\sectionpage}
  \fi
}
\AtBeginSubsection{
  \let\insertsubsectionnumber\relax
  \let\subsectionname\relax
  \frame{\subsectionpage}
}

\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{0}

\usepackage[BoldFont,SlantFont]{xeCJK}

\setCJKmainfont[BoldFont=Microsoft YaHei]{SimSun}
\setCJKsansfont[BoldFont=Microsoft YaHei Bold]{Microsoft YaHei}
\setCJKromanfont{SimSun}
\setCJKmonofont{SimSun}

\IfFileExists{C:/Windows/Fonts/AdobeSongStd-Light.otf}{
  \setCJKfamilyfont{song}{AdobeSongStd-Light}}{
  \setCJKfamilyfont{song}{SimSun.ttc}}

\IfFileExists{C:/Windows/Fonts/AdobeHeitiStd-Regular.otf}{
  \setCJKfamilyfont{hei}{AdobeHeitiStd-Regular}}{
  \setCJKfamilyfont{hei}{SimHei.ttf}}

\IfFileExists{C:/Windows/Fonts/AdobeKaitiStd-Regular.otf}{
  \setCJKfamilyfont{kai}{AdobeKaitiStd-Regular}}{
  \setCJKfamilyfont{kai}{SimKai.ttf}}

\IfFileExists{C:/Windows/Fonts/AdobeFangsongStd-Regular.otf}{
  \setCJKfamilyfont{fs}{AdobeFangsongStd-Regular}}{
  \setCJKfamilyfont{fs}{SimFang.ttf}}

\author[Jin]{\CJKfamily{kai}Jin \\ jinlin@zuel.edu.cn \\}
\institute[中南财经政法大学统计与数学学院]{\normalsize\CJKfamily{kai}中南财经政法大学统计与数学学院}

\date{\today}
\date{2020年6月}





\renewcommand{\contentsname}{\centerline{\textcolor{violet}{目 \ \ 录}}}    % 将Contents改为目录
\renewcommand{\abstractname}{摘 \ \ 要}      % 将Abstract改为摘要
\renewcommand{\refname}{参考文献}            % 将Reference改为参考文献
\renewcommand\tablename{表}
\renewcommand\figurename{图}
\renewcommand{\today}{\number\year 年 \number\month 月 \number\day 日}

\PassOptionsToPackage{dvipsnames}{xcolor}
\PassOptionsToPackage{colorlinks=true,citecolor=blue, urlcolor=blue, linkcolor=violet, bookmarksdepth=4,bookmarksopen=true,bookmarksopenlevel=2}{hyperref}

\usepackage{lscape}
\usepackage{indentfirst}
\usepackage{textcomp}                      % provide many text symbols
\usepackage{setspace}                      % 各种间距设置


% ---------------------------------Table------------------------------
\usepackage{booktabs}
\usepackage{array}                         % 提供表格中每一列的宽度及位置支持
\usepackage{multirow}
\usepackage{rotating}
\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}

%\sloppy
%\linespread{1.0}                           % 设置行距
\setlength{\parindent}{22pt}
%\setlength{\parskip}{1ex plus 0.5ex minus 0.2ex}


%% 参考文献
\usepackage{gbt7714}
\usepackage{natbib}
\setlength{\bibsep}{2pt}


\usepackage[utf8]{inputenc}
% Package fontenc omitted
% Package fixltx2e omitted
\usepackage{graphicx}
% Package longtable omitted
% Package float omitted
% Package wrapfig omitted
\usepackage{soul}
% Package textcomp omitted
\usepackage{marvosym}
\usepackage{wasysym}
\usepackage{latexsym}
\usepackage{amssymb}
% Package hyperref omitted
\usepackage{listings}
\newcommand{\passthrough}[1]{#1}
\usepackage{tikz}

						   
\setmonofont{Consolas} % listings 中支持 consolas 字体，必需配合上面usepackage{fontenc} 中不出现[T1]才可以

\lstset{numbers=left, numberstyle=\ttfamily\tiny\color{Gray}, stepnumber=1, numbersep=8pt,
  frame=leftline,
  framexleftmargin=0mm,
  rulecolor=\color{CadetBlue},
  backgroundcolor=\color{Periwinkle!20},
  stringstyle=\color{CadetBlue},
  flexiblecolumns=false,
  aboveskip=5pt,
  belowskip=0pt,
  language=R,
  basicstyle=\ttfamily\footnotesize,
  columns=flexible,
  keepspaces=true,
  breaklines=true,
  extendedchars=true,
  texcl=false,  % 必须设置为false设置为true的时候 R 代码中不能含有多个注释符号 #
  upquote=true, % 设置 引号为竖引号，但必需配合 上面 fontenc T1 使用，fontenc T1 又不能使用 consolas，所以冲突
  showstringspaces=false,
  keywordstyle=\bfseries,
  keywordstyle=\color{Purple},
  xleftmargin=20pt,
  xrightmargin=10pt,
  morecomment=[s]{\#}{\#},
  commentstyle=\color{OliveGreen!60}\scriptsize,
  tabsize=4}

\tolerance=1000
\usetheme{default}
\setcounter{secnumdepth}{4}

\usetheme{default}
\useinnertheme[shadow]{rounded}
\useoutertheme{infolines}
\usecolortheme{seahorse}
\setbeamercolor{frametitle}{fg=Blue, bg=white}
\setbeamercolor{titlelike}{parent=structure}
\setbeamertemplate{caption}[numbered]
\setbeamertemplate{section in toc shaded}[default][50]
\setbeamertemplate{frametitle continuation}[from second][(续)] % 改变
\setbeamertemplate{subsection in toc shaded}[default][20]
\setbeamertemplate{subsection in toc}[square]
\logo{\includegraphics[height=0.6cm,width=0.6cm]{znufelogo.jpg}}
\setbeamercovered{transparent}
\setCJKmainfont[BoldFont={* Bold}]{Microsoft YaHei}
\usefonttheme[onlylarge]{structuresmallcapsserif}
\usefonttheme[onlymath]{serif}
\setbeamertemplate{frametitle}{\bfseries\insertframetitle\par\vskip-6pt}
\setbeamerfont{block title}{shape=\normalfont, series=\bfseries}
\setbeamercolor{block title}{fg=violet}
\AtBeginSection[]
{
\setcounter{tocdepth}{2}
\frame[shrink=5]{\tableofcontents[currentsection, hideothersubsections]}
}
\AtBeginSubsection[] % Do nothing for \subsection*
{
\begin{frame}<beamer>
\frametitle{}
\large \tableofcontents[currentsection, sectionstyle=shaded/hide, subsectionstyle=show/shaded/hide]
\end{frame}
}
\setlength{\parskip}{1ex plus 0.5ex minus 0.2ex}
\everydisplay{\color{blue}}


\title{Numpy 用法}

\makeatletter
\@ifpackageloaded{subfig}{}{\usepackage{subfig}}
\@ifpackageloaded{caption}{}{\usepackage{caption}}
\captionsetup[subfloat]{margin=0.5em}
\AtBeginDocument{%
\renewcommand*\figurename{Figure}
\renewcommand*\tablename{Table}
}
\AtBeginDocument{%
\renewcommand*\listfigurename{List of Figures}
\renewcommand*\listtablename{List of Tables}
}
\@ifpackageloaded{float}{}{\usepackage{float}}
\floatstyle{ruled}
\@ifundefined{c@chapter}{\newfloat{codelisting}{h}{lop}}{\newfloat{codelisting}{h}{lop}[chapter]}
\floatname{codelisting}{Listing}
\newcommand*\listoflistings{\listof{codelisting}{List of Listings}}
\makeatother

\begin{document}
\frame{\titlepage}

\begin{frame}{\textcolor{violet}{\normalfont\Large \CJKfamily{kai}大\ \ 纲 }} \textcolor{violet}{}
\tableofcontents[hideallsubsections]
\end{frame}

\hypertarget{section}{%
\section{介绍}\label{section}}

\begin{frame}{实际情况}
\protect\hypertarget{section-1}{}

\begin{enumerate}
\tightlist
\item
  初始发行版： Numeric，1995年； 作为NumPy，2006年
\item
  稳定版本：1.11.2 / 2016年10月3日；
\item
  网站：\url{http://www.numpy.org}
\item
  历史记录：\url{https://en.wikipedia.org/wiki/NumPy}
\end{enumerate}

\end{frame}

\begin{frame}{什么是NumPy?}
\protect\hypertarget{numpy}{}

\begin{enumerate}
\item
  NumPy是Python中科学计算的基本软件包。
\item
  这是一个提供多维数组的Python库对象，各种派生对象（例如蒙版数组和矩阵），以及用于快速操作的各种例程数组，包括
\item
  数值型
\item
  逻辑型
\item
  形状操纵，
\item
  排序，选择，I / O，
\item
  离散傅立叶变换，基本线性代数，
\item
  基本的统计运算，随机模拟等等。
\end{enumerate}

\end{frame}

\begin{frame}{NumPy}
\protect\hypertarget{numpy-1}{}

\begin{enumerate}
\tightlist
\item
  NumPy包的核心是ndarray对象。
\item
  这封装了同类数据类型的n维数组，在编译的代码中执行了许多操作性能。
\item
  关于序列大小和速度的要点特别重要在科学计算中。
\end{enumerate}

\end{frame}

\begin{frame}{ndarray对象}
\protect\hypertarget{ndarray}{}

\begin{enumerate}
\tightlist
\item
  向量化：向量化描述了代码中没有任何显式的循环，索引等操作-这些事情当然发生在优化的预编译C代码的``幕后''中。
\item
  广播机制：广播机制是用于描述操作的隐式逐元素行为的术语。
\item
  NumPy完全支持ndarray的面向对象方法。
  ndarray是一个类，具有许多方法和属性。
\end{enumerate}

\end{frame}

\hypertarget{section-2}{%
\section{基础}\label{section-2}}

\hypertarget{section-3}{%
\subsection{数组创建}\label{section-3}}

\begin{frame}[fragile]{数组函数}
\protect\hypertarget{section-4}{}

\begin{enumerate}
\tightlist
\item
  使用以下命令从常规Python列表或元组创建数组\textbf{\passthrough{\lstinline!array!}
  }函数。推导所得数组的类型 根据序列中元素的类型。
\item
  array将序列序列转换为二维数组，序列的序列变成三维数组等等。
\item
  通常，数组的元素最初是未知的，但是其大小是众所周知的。
\end{enumerate}

\end{frame}

\begin{frame}[fragile]{具有初始占位符内容的数组}
\protect\hypertarget{section-5}{}

\begin{enumerate}
\tightlist
\item
  函数** zeros **创建一个充满零的数组，
\item
  函数** ones **创建一个全为1的数组，
\item
  函数\textbf{\passthrough{\lstinline!empty!}
  }创建一个数组，其初始内容为随机且取决于内存的状态。
\item
  函数diag创建对角线数组
\item
  函数\textbf{ʻeye\passthrough{\lstinline!**或**ʻidentity!}
  }创建一个带有1的数组在对角线上， 在其他地方为零。
\end{enumerate}

\end{frame}

\begin{frame}[fragile]{\passthrough{\lstinline!arange!} 和
\passthrough{\lstinline!linspace!} 的函数}
\protect\hypertarget{arange--linspace-}{}

\begin{enumerate}
\item
  \textbf{\passthrough{\lstinline!arange!}}:
\item
  \textbf{\passthrough{\lstinline!linspace!}}:
\end{enumerate}

\end{frame}

\begin{frame}{ndarray对象的属性}
\protect\hypertarget{ndarray-1}{}

\begin{enumerate}
\tightlist
\item
  ndarray.ndim
\item
  ndarray.shape
\item
  ndarray.size
\item
  ndarray.dtype
\item
  ndarray.itemsize
\item
  ndarray.data
\end{enumerate}

\end{frame}

\hypertarget{section-6}{%
\subsection{基本操作}\label{section-6}}

\begin{frame}{基本操作}
\protect\hypertarget{section-7}{}

\begin{enumerate}
\tightlist
\item
  数组上的算术运算符按元素方式应用。创建一个新的数组并填充结果。
\item
  矩阵乘积可使用点函数或方法执行:
\item
  许多一元运算，比如计算数组中所有元素的总和，都是作为ndarray类的方法实现的。
\item
  通过指定轴参数，可以应用一个沿着数组的指定轴进行的操作(类似于R中的apply函数)。
\end{enumerate}

\end{frame}

\begin{frame}[fragile]{例子}
\protect\hypertarget{section-8}{}

\begin{lstlisting}[language=Python]
import numpy as np
a=np.arange(4)
b=np.array([2,5,8,9])
a*b
\end{lstlisting}

\begin{lstlisting}[language=Python]
A=np.arange(12).reshape(3,4)
B=np.arange(13,25).reshape(4,3)
np.dot(A, B)
\end{lstlisting}

\begin{lstlisting}[language=Python]
A.dot(B)
\end{lstlisting}

\begin{lstlisting}[language=Python]
A.sum()
\end{lstlisting}

\begin{lstlisting}[language=Python]
A.sum(axis=0)
\end{lstlisting}

\begin{lstlisting}[language=Python]
A.sum(axis=1)
\end{lstlisting}

\begin{lstlisting}[language=Python]
"""END"""
\end{lstlisting}

\end{frame}

\begin{frame}[fragile]{通用函数}
\protect\hypertarget{section-9}{}

\begin{enumerate}
\tightlist
\item
  NumPy提供了熟悉的数学函数，如sin、cos和exp。
\item
  在NumPy中，这些函数称为``通用函数''(ufunc)。
\item
  在NumPy中，这些函数按元素对数组进行操作，生成一个数组作为输出。
\end{enumerate}

\begin{lstlisting}[language=Python]
A=np.arange(12).reshape(3,4)
np.exp(A)
\end{lstlisting}

\begin{lstlisting}[language=Python]
np.sqrt(A)
\end{lstlisting}

\begin{lstlisting}[language=Python]
"""END"""
\end{lstlisting}

\end{frame}

\hypertarget{section-10}{%
\subsection{索引、切片和迭代}\label{section-10}}

\begin{frame}[fragile]{索引、切片和迭代}
\protect\hypertarget{section-11}{}

\begin{enumerate}
\tightlist
\item
  一维数组可以被索引、切片和迭代，就像列表和其他Python序列一样。
\end{enumerate}

\begin{lstlisting}[language=Python]
x=np.arange(12)**2
x[3]
\end{lstlisting}

\begin{lstlisting}[language=Python]
x[2:6]
\end{lstlisting}

\begin{lstlisting}[language=Python]
x[7:]
\end{lstlisting}

\begin{lstlisting}[language=Python]
x[::-1]
\end{lstlisting}

\begin{lstlisting}[language=Python]
x[9:2:-3]
\end{lstlisting}

\begin{lstlisting}[language=Python]
"""END"""
\end{lstlisting}

\end{frame}

\begin{frame}[fragile]{索引、切片和迭代}
\protect\hypertarget{section-12}{}

\begin{enumerate}
\tightlist
\item
  多维数组每个轴可以有一个索引。这些索引以元组的形式给出，中间用逗号分隔。
\item
  当提供的索引少于轴的数量时，缺失的索引被认为是完整的片。
\end{enumerate}

\begin{lstlisting}[language=Python]
A=np.arange(24).reshape(4,6)
A[2,3]
\end{lstlisting}

\begin{lstlisting}[language=Python]
A[1:3, 2:4]
\end{lstlisting}

\begin{lstlisting}[language=Python]
A[1]
\end{lstlisting}

\begin{lstlisting}[language=Python]
A[:, 2:4]
\end{lstlisting}

\begin{lstlisting}[language=Python]
A[..., 3]
\end{lstlisting}

\begin{lstlisting}[language=Python]
"""END"""
\end{lstlisting}

\end{frame}

\begin{frame}[fragile]{索引、切片和迭代}
\protect\hypertarget{section-13}{}

\begin{enumerate}
\tightlist
\item
  点(\ldots)表示生成完整索引元组所需的冒号。
\item
  例如，如果x是一个有5个轴的数组，那么
\end{enumerate}

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!x[1, 2, ...]!} is equivalent to
  \passthrough{\lstinline!x[1, 2, :, :, :]!},
\item
  \passthrough{\lstinline!x[..., 3]!} to
  \passthrough{\lstinline!x[:, : ,: ,:, 3]!}
\item
  \passthrough{\lstinline!x[4, ..., 5, :]!} to
  \passthrough{\lstinline!x[4, :, :, 5, :]!}
\end{itemize}

\end{frame}

\begin{frame}[fragile]{索引、切片和迭代}
\protect\hypertarget{section-14}{}

\begin{enumerate}
\tightlist
\item
  迭代多维数组是在第一个轴上完成的
\item
  如果想对数组中的每个元素执行操作，可以使用flat属性，它是数组中所有元素的迭代
  器
\end{enumerate}

\begin{lstlisting}[language=Python]
import numpy as np
A=np.arange(24).reshape(4,6)
for i in A:
    """打印A的各行"""
    print(i) 
\end{lstlisting}

\begin{lstlisting}[language=Python]
for i in A.flat:
    """打印A中的每个元素"""
    print(i)
\end{lstlisting}

\begin{lstlisting}[language=Python]
"""END"""
\end{lstlisting}

\end{frame}

\hypertarget{section-15}{%
\section{形状操作}\label{section-15}}

\begin{frame}[fragile]{改变数组的形状}
\protect\hypertarget{section-16}{}

\begin{enumerate}
\tightlist
\item
  数组的形状由每个轴上元素的数目决定
\item
  数组的形状可以通过多种命令进行改变
\item
  要注意的是以下三种命令都返回一个调整过的数组，但并不改变原始数组：

  \begin{enumerate}
  \tightlist
  \item
    \passthrough{\lstinline!ndarray.ravel(), ndarray.T, ndarry.reshape!}
  \end{enumerate}
\item
  \passthrough{\lstinline!ndarray.resize!} 方法调整的是数组本身
\end{enumerate}

\begin{lstlisting}[language=Python]
import numpy as np
a = np.floor(10 * np.random.random((3,4)))
a.shape
\end{lstlisting}

\begin{lstlisting}[language=Python]
a.ravel()
\end{lstlisting}

\begin{lstlisting}[language=Python]
a.T
\end{lstlisting}

\begin{lstlisting}[language=Python]
a.reshape(2,6)
\end{lstlisting}

\begin{lstlisting}[language=Python]
a.resize(2,6)

"""END"""
\end{lstlisting}

\end{frame}

\begin{frame}[fragile]{将不同数组堆叠在一起}
\protect\hypertarget{section-17}{}

\begin{enumerate}
\tightlist
\item
  \passthrough{\lstinline!hstack, vstack!}
\item
  \passthrough{\lstinline!column\_stack, row\_stack!}
\item
  \passthrough{\lstinline!concatenate!}
\item
  \passthrough{\lstinline!c\_, r\_!}
\end{enumerate}

\end{frame}

\begin{frame}[fragile]{将一个数组拆分为几个较小的数组}
\protect\hypertarget{section-18}{}

\begin{enumerate}
\tightlist
\item
  \passthrough{\lstinline!hsplit!}
\item
  \passthrough{\lstinline!vsplit!}
\item
  \passthrough{\lstinline!array\_split!}
\end{enumerate}

\end{frame}

\hypertarget{section-19}{%
\section{奇妙的索引和索引技巧}\label{section-19}}

\begin{frame}[fragile]{用一维索引数组进行索引}
\protect\hypertarget{section-20}{}

\begin{enumerate}
\tightlist
\item
  使用 \passthrough{\lstinline!np.array!}
  对象作为索引下标可以取非连续元素
\end{enumerate}

\begin{lstlisting}[language=Python]
a = np.arange(12) ** 2 # the first 12 square numbers
i = np.array( [ 1,1,3,8,5 ] ) # an array of indices
a[i] # the elements of a at the positions i
\end{lstlisting}

\begin{lstlisting}[language=Python]
np.array([ 1, 1, 9, 64, 25])
\end{lstlisting}

\begin{lstlisting}[language=Python]
j = np.array( [ [ 3, 4], [ 9, 7 ] ] )
a[j]
\end{lstlisting}

\begin{lstlisting}[language=Python]
"""END"""
\end{lstlisting}

\end{frame}

\begin{frame}[fragile]{用二维索引数组进行索引}
\protect\hypertarget{section-21}{}

\begin{enumerate}
\tightlist
\item
  我们也可以给出多维索引。每个维度的索引数组必须具有相同的形状。
\item
  当然，我们也可以将i和j放入一个序列（比如一个列表）中，然后使用列表进行索引。
\end{enumerate}

\begin{lstlisting}[language=Python]
a = np.arange(12).reshape(3,4)
i = np.array([[0,1], [1,2]])
j = np.array([[2,1], [3,3]])

a[i]
\end{lstlisting}

\begin{lstlisting}[language=Python]
a[i,j]
\end{lstlisting}

\begin{lstlisting}[language=Python]
a[i, 2]
\end{lstlisting}

\begin{lstlisting}[language=Python]
a[:,j]
\end{lstlisting}

\begin{lstlisting}[language=Python]
L = [i,j]
a[L]
\end{lstlisting}

\begin{lstlisting}[language=Python]
"""END"""
\end{lstlisting}

\end{frame}

\begin{frame}[fragile]{用布尔数组进行索引}
\protect\hypertarget{section-22}{}

\begin{enumerate}
\tightlist
\item
  使用与原始数组具有相同形状的布尔数组
\item
  对数组的每个维度，我们给出一个一维布尔数组，以选择我们想要的切片
\item
  要注意的是，一维布尔数组的长度须与你想要的切片的维度（或轴）的长度一致。
\end{enumerate}

\begin{lstlisting}[language=Python]
a = np.arange(12).reshape(3,4)
b=a>4
a[b]
\end{lstlisting}

\begin{lstlisting}[language=Python]
a[b]=0

a = np.arange(12).reshape(3,4)
b1 = np.array([False,True,True])
b2 = np.array([True,False,True,False])
a[b1,:]
\end{lstlisting}

\begin{lstlisting}[language=Python]
a[b1]
\end{lstlisting}

\begin{lstlisting}[language=Python]
a[:,b2]
\end{lstlisting}

\begin{lstlisting}[language=Python]
a[b1,b2]
\end{lstlisting}

\begin{lstlisting}[language=Python]
"""END"""
\end{lstlisting}

\end{frame}

\begin{frame}[fragile]{用字符串进行索引}
\protect\hypertarget{section-23}{}

\begin{enumerate}
\tightlist
\item
  结构化数组是ndarray，其数据类型是由命名字段的序列组织成的简单数据类型的组合。
\item
  你可以通过字段名进行索引，来获取和修改结构化数组的单个字段。
\item
  可以使用多字段索引来对结构化数组进行索引和赋值，其中的索引是字段名的一个列表。
\end{enumerate}

\begin{lstlisting}[language=Python]
x = np.array([('Rex', 9, 81.0), ('Fido', 3, 27.0)],
             dtype=[('name', 'U10'), ('age', 'i4'), ('weight', 'f4')])
x['name']
\end{lstlisting}

\begin{lstlisting}[language=Python]
x[['name', 'age']]
\end{lstlisting}

\begin{lstlisting}[language=Python]
"""END"""
\end{lstlisting}

\end{frame}

\begin{frame}[fragile]{ix\textsubscript{()} 函数}
\protect\hypertarget{ix-}{}

\begin{enumerate}
\tightlist
\item
  ix\_ 函数可用于组合不同的向量，以获得每个n耦合的结果。(类似于R中的
  \passthrough{\lstinline!expand.grid!} 函数)
\item
  例如，如果你想要计算从向量a, b和c中提取的所有三元组的a+b*c：
\end{enumerate}

\begin{lstlisting}[language=Python]
a = np.array([2,3,4,5])
b = np.array([8,5,4])
c = np.array([5,4,6,8,3])
ax,bx,cx = np.ix_(a,b,c)

result = ax+bx * cx
result
\end{lstlisting}

\begin{lstlisting}[language=Python]
"""END"""
\end{lstlisting}

\end{frame}

\hypertarget{universal-functions-ufunc}{%
\section{通用函数UNIVERSAL FUNCTIONS
(UFUNC)}\label{universal-functions-ufunc}}

\begin{frame}{简介}
\protect\hypertarget{section-24}{}

\begin{enumerate}
\tightlist
\item
  通用函数（简称为ufunc）是一种ndarrays 以逐元素方式操作的函数；
\item
  也就是说，ufunc是一个函数的``矢量化''包装器，它接受固定数量的特定输入并产生固定数量的特定输出；
\item
  在Numpy中，通用函数是numpy.ufunc类的实例；
\item
  许多内置函数都是在编译的C代码中实现的。
\end{enumerate}

\end{frame}

\begin{frame}{常见通用函数}
\protect\hypertarget{section-25}{}

\begin{enumerate}
\tightlist
\item
  数学运算
\item
  三角函数
\item
  浮动函数
\item
  。。。
\end{enumerate}

\end{frame}

\hypertarget{section-26}{%
\section{统计功能}\label{section-26}}

\begin{frame}{顺序统计量}
\protect\hypertarget{section-27}{}

\begin{longtable}[]{@{}ll@{}}
\toprule
函数 & 功能\tabularnewline
\midrule
\endhead
amin(a\(, axis, out, keepdims\)) &
返回数组或沿着某轴方向上元素的最小值\tabularnewline
amax(a\(, axis, out, keepdims\)) &
返回数组或沿着某轴方向上元素的最大值\tabularnewline
nanmin(a\(, axis, out, keepdims\)) &
返回数组或沿着某轴方向上元素的最小值，忽略NAN\tabularnewline
nanmax(a\(, axis, out, keepdims\)) &
返回数组或沿着某轴方向上元素的最小值，忽略NAN\tabularnewline
ptp(a\(, axis, out\)) &
沿着某轴方向上元素的取值范围（最大值-最小值）\tabularnewline
percentile(a, q\(, axis, out, ...\)) &
计算沿指定轴的数据的第q个百分位数\tabularnewline
nanpercentile(a, q\(, axis, out, ...\)) &
计算沿指定轴的数据的第q个百分位数，同时忽略NAN值\tabularnewline
\bottomrule
\end{longtable}

\end{frame}

\begin{frame}{平均数和方差}
\protect\hypertarget{section-28}{}

\begin{longtable}[]{@{}ll@{}}
\toprule
函数 & 功能\tabularnewline
\midrule
\endhead
median(a\(, axis, out, overwrite~input~, keepdims\)) &
计算沿指定轴的中位数\tabularnewline
average(a\(, axis, weights, returned\)) &
计算沿指定轴的加权平均数\tabularnewline
mean(a\(, axis, dtype, out, keepdims\)) &
计算沿指定轴的算术平均数\tabularnewline
std(a\(, axis, dtype, out, ddof, keepdims\)) &
计算沿指定轴的标准差\tabularnewline
var(a\(, axis, dtype, out, ddof, keepdims\)) &
计算沿指定轴的方差\tabularnewline
nanmedian(a\(, axis, out, overwrite~input~, ...\)) &
计算沿指定轴的中位数，同时忽略NaN\tabularnewline
nanmean(a\(, axis, dtype, out, keepdims\)) &
计算沿指定轴的算术平均数，同时忽略NaN\tabularnewline
nanstd(a\(, axis, dtype, out, ddof, keepdims\)) &
计算沿指定轴的标准差，同时忽略NaN\tabularnewline
nanvar(a\(, axis, dtype, out, ddof, keepdims\)) &
计算沿指定轴的方差，同时忽略NaN\tabularnewline
\bottomrule
\end{longtable}

注：几何平均数，调和平均数函数在scipy中

\end{frame}

\begin{frame}{相关性}
\protect\hypertarget{section-29}{}

\begin{longtable}[]{@{}ll@{}}
\toprule
函数 & 功能\tabularnewline
\midrule
\endhead
corrcoef(x\(, y, rowvar, bias, ddof\)) &
返回皮尔逊乘积矩相关系数\tabularnewline
correlate(a, v\(, mode\)) & 两个一维序列的相关关系\tabularnewline
cov(m\(, y, rowvar, bias, ddof, fweights, ...\)) &
根据已知数据和权重，求协方差矩阵\tabularnewline
\bottomrule
\end{longtable}

\end{frame}

\begin{frame}{直方图}
\protect\hypertarget{section-30}{}

\end{frame}

\hypertarget{numpy.linalg}{%
\section{线性代数 (numpy.linalg)}\label{numpy.linalg}}

\begin{frame}{常见矩阵运算- 矩阵与向量积}
\protect\hypertarget{section-31}{}

\begin{longtable}[]{@{}ll@{}}
\toprule
函数 & 功能\tabularnewline
\midrule
\endhead
dot(a, b) & 两个数组的点积\tabularnewline
vdot(a, b) & 两个向量的点积\tabularnewline
inner(a, b) & 两个数组的内积\tabularnewline
outer(a, b) & 两个向量的外积\tabularnewline
linalg.matrix\textsubscript{power}(M, n) &
将一个方阵转化到（整数）次方（矩阵乘幂）\tabularnewline
kron(a, b) & 两个矩阵的Kronecker积\tabularnewline
\bottomrule
\end{longtable}

\end{frame}

\begin{frame}{常见矩阵运算- 矩阵分解}
\protect\hypertarget{section-32}{}

\begin{longtable}[]{@{}ll@{}}
\toprule
函数 & 功能\tabularnewline
\midrule
\endhead
linalg.cholesky(a) & 求Cholesky分解\tabularnewline
linalg.qr(a) & 计算矩阵的qr分解\tabularnewline
linalg.svd(a) & 奇异值分解\tabularnewline
linalg.eig(a) & 计算方阵的特征值和特征向量\tabularnewline
scipy.linalg.lu(a) & 计算矩阵的LU分解\tabularnewline
\bottomrule
\end{longtable}

\end{frame}

\begin{frame}{常见矩阵运算- 范数等}
\protect\hypertarget{section-33}{}

\begin{longtable}[]{@{}ll@{}}
\toprule
函数 & 功能\tabularnewline
\midrule
\endhead
linalg.norm(x) & 求矩阵或向量的范数\tabularnewline
linalg.cond(x) & 计算矩阵的条件数\tabularnewline
linalg.det(a) & 计算一个数组的行列式的值\tabularnewline
linalg.matrix\textsubscript{rank}(M) &
使用SVD法（奇异值分解）求矩阵的秩\tabularnewline
trace(a) & 求矩阵的迹（对角线元素之和）\tabularnewline
\bottomrule
\end{longtable}

\end{frame}

\begin{frame}{常见矩阵运算- 解线性方程组与逆矩阵}
\protect\hypertarget{section-34}{}

\begin{longtable}[]{@{}ll@{}}
\toprule
函数 & 功能\tabularnewline
\midrule
\endhead
linalg.solve(a, b) & 求解线性矩阵方程或线性标量方程组\tabularnewline
linalg.tensorsolve(a, b) & 求解张量方程Ax=b中的x\tabularnewline
linalg.lstsq(a, b) & 求解线性矩阵方程的最小二乘解\tabularnewline
linalg.inv(a) & 计算矩阵的（乘法）逆矩阵\tabularnewline
linalg.pinv(a) & 计算矩阵的（Moore-Penrose）伪逆\tabularnewline
\bottomrule
\end{longtable}

\end{frame}

\hypertarget{numpy.random}{%
\section{随机抽样 (numpy.random)}\label{numpy.random}}

\begin{frame}[fragile]{简介}
\protect\hypertarget{section-35}{}

\begin{enumerate}
\tightlist
\item
  下面这些函数主要用于随机抽样和生成随机数字，关于概率，分位点等计算见
  \passthrough{\lstinline!scipy.stats!} 模块
\item
  下面函数都以 \passthrough{\lstinline!np.random.!} 开始
\item
  有很多功能相同名字不同的函数
\end{enumerate}

\end{frame}

\begin{frame}{简单随机数据}
\protect\hypertarget{section-36}{}

\scriptsize

\begin{longtable}[]{@{}ll@{}}
\toprule
函数 & 功能\tabularnewline
\midrule
\endhead
rand(d0, d1, \ldots, dn) & 给定模型的随机值\tabularnewline
randn(d0, d1, \ldots, dn) &
从``标准正态''分布中返回一个或多个样本\tabularnewline
randint(low\(, high, size, dtype\)) &
从低(含)到高(不含)返回随机整数\tabularnewline
random\_integers(low\(, high, size\)) &
类型为np.int的随机整数，介于高低之间，都包括在内\tabularnewline
random\_sample(\(size\)) & 返回半开区间内的随机浮点数{[}0.0,
1.0)\tabularnewline
random(\(size\)) & 返回半开区间内的随机浮点数{[}0.0, 1.0)\tabularnewline
ranf(\(size\)) & 返回半开区间内的随机浮点数{[}0.0, 1.0)\tabularnewline
sample(\(size\)) & 返回半开区间内的随机浮点数{[}0.0, 1.0)\tabularnewline
choice(a\(, size, replace, p\)) &
从给定的一维数组中生成一个随机样本\tabularnewline
bytes(length) & 返回随机字节\tabularnewline
\bottomrule
\end{longtable}

\end{frame}

\begin{frame}{排列}
\protect\hypertarget{section-37}{}

\begin{longtable}[]{@{}ll@{}}
\toprule
函数 & 功能\tabularnewline
\midrule
\endhead
shuffle(x) & 通过变换序列的内容就地修改序列\tabularnewline
permutation(x) &
随机排列一个序列，或返回一个经过排列的范围\tabularnewline
\bottomrule
\end{longtable}

\end{frame}

\begin{frame}{Distribution 分布}
\protect\hypertarget{distribution-}{}

\scriptsize

\begin{longtable}[]{@{}ll@{}}
\toprule
函数 & 功能\tabularnewline
\midrule
\endhead
beta(a, b\(, size\)) & 从Beta分布中抽取样本\tabularnewline
binomial(n, p\(, size\)) & 从二项分布中抽取样本\tabularnewline
chisquare(df\(, size\)) & 从卡方分布中抽取样本\tabularnewline
dirichlet(alpha\(, size\)) & 从狄利克雷分布中抽取样本\tabularnewline
exponential(\(scale, size\)) & 从指数分布中抽取样本\tabularnewline
f(dfnum, dfden\(, size\)) & 从F分布中抽取样本\tabularnewline
gamma(shape\(, scale, size\)) & 从Gamma分布中抽取样本\tabularnewline
geometric(p\(, size\)) & 从几何分布中抽取样本\tabularnewline
gumbel(\(loc, scale, size\)) & 从耿贝尔分布中抽取样本\tabularnewline
hypergeometric(ngood, nbad, nsample\(, size\)) &
从超几何分布中抽取样本\tabularnewline
laplace(\(loc, scale, size\)) &
从具有指定位置(或平均值)和比例(衰减)的拉普拉斯或双指数分布中抽取样本\tabularnewline
logistic(\(loc, scale, size\)) & 从logistic分布中抽取样本\tabularnewline
lognormal(\(mean, sigma, size\)) &
从对数正态分布中抽取样本\tabularnewline
logseries(p\(, size\)) & 从对数级数分布中抽取样本\tabularnewline
\bottomrule
\end{longtable}

\end{frame}

\begin{frame}{分布}
\protect\hypertarget{section-38}{}

\scriptsize

\begin{longtable}[]{@{}ll@{}}
\toprule
函数 & 功能\tabularnewline
\midrule
\endhead
multivariate\_normal(mean, cov\(, size, ...\)) &
从多元正态分布中抽取随机样本\tabularnewline
negative\_binomial(n, p\(, size\)) &
从负二项分布中抽取样本\tabularnewline
noncentral\_chisquare(df, nonc\(, size\)) &
从非中心卡方分布中抽取样本\tabularnewline
noncentral\_f(dfnum, dfden, nonc\(, size\)) &
从非中心F分布中抽取样本\tabularnewline
normal(\(loc, scale, size\)) &
从正态(高斯)分布中抽取随机样本\tabularnewline
pareto(a\(, size\)) & 从指定形状的Pareto
II或Lomax分布中抽取样本\tabularnewline
poisson(\(lam, size\)) & 从泊松分布中抽取样本\tabularnewline
power(a\(, size\)) &
从指数为正a-1的幂分布中抽取{[}0,1{]}内的样本\tabularnewline
rayleigh(\(scale, size\)) & 从瑞利分布中抽取样本\tabularnewline
standard\_cauchy(\(size\)) &
从模式为0的标准柯西分布中抽取样本\tabularnewline
standard\_exponential(\(size\)) &
从标准指数分布中抽取样本\tabularnewline
standard\_gamma(shape\(, size\)) &
从标准Gamma分布中抽取样本\tabularnewline
standard\_normal\_(\(size\)) &
从标准正态分布中抽取样本（均值为0，标准差为1）\tabularnewline
standard\_t(df\(, size\)) &
从自由度为df的标准学生t分布中抽取样本\tabularnewline
triangular(left, mode, right\(, size\)) &
从区间{[}左，右{]}的三角形分布中抽取样本\tabularnewline
uniform(\(low, high, size\)) & 从均匀分布中抽取样本\tabularnewline
vonmises(mu, kappa\(, size\)) & 从冯·米塞斯分布中抽取样本\tabularnewline
wald(mean, scale\(, size\)) &
从Wald或逆高斯分布中抽取样本\tabularnewline
weibull(a\(, size\)) & 从威布尔分布中抽取样本\tabularnewline
zipf(a\(, size\)) & 从Zipf分布中抽取样本\tabularnewline
\bottomrule
\end{longtable}

\end{frame}

\begin{frame}{随机数发生器}
\protect\hypertarget{section-39}{}

\begin{longtable}[]{@{}ll@{}}
\toprule
函数 & 功能\tabularnewline
\midrule
\endhead
RandomState(\(seed\)) & Mersenne
Twister伪随机数生成器的容器\tabularnewline
seed(\(seed\)) & 种子生成器\tabularnewline
get\_state() & 返回表示生成器内部状态的元组\tabularnewline
set\_state(state) & 从元组设置生成器的内部状态\tabularnewline
\bottomrule
\end{longtable}

\end{frame}

\hypertarget{section-40}{%
\section{函数和方法概述}\label{section-40}}

\begin{frame}{函数和方法概述}
\protect\hypertarget{section-41}{}

\begin{enumerate}
\item
  \textbf{创建数组}:

  arange, array, copy, empty, empty\_like, eye, fromfile,
  fromfunction,identity, linspace, logspace, mgrid, ogrid, ones,
  ones\_like, r, zeros, zeros\_like
\item
  \textbf{转换}:

  ndarray.astype, atleast\_1d, atleast\_2d, atleast\_3d, mat
\item
  \textbf{操作}:

  array\_split, column\_stack, concatenate, diagonal, dsplit, dstack,
  hsplit,hstack, ndarray.item, newaxis, ravel, repeat, reshape, resize,
  squeeze, swapaxes, take, transpose, vsplit, vstack
\end{enumerate}

\end{frame}

\begin{frame}{函数和方法概述}
\protect\hypertarget{section-42}{}

\begin{enumerate}
\item
  \textbf{问题}:

  all, any, nonzero, where
\item
  \textbf{排序}:

  argmax, argmin, argsort, max, min, ptp, searchsorted, sort
\item
  \textbf{运作}:

  choose, compress, cumprod, cumsum, inner, ndarray.fill, imag, prod,
  put, putmask,real, sum
\item
  \textbf{基本统计量}:

  cov, mean, std, var
\item
  \textbf{基本线性代数}:

  cross, dot, outer, linalg.svd, vdot
\end{enumerate}

\end{frame}

\hypertarget{other-subpackages-}{%
\section{Other Subpackages 其他子包}\label{other-subpackages-}}

\begin{frame}{Numpy中的其他常用模块}
\protect\hypertarget{numpy-2}{}

\begin{enumerate}
\tightlist
\item
  String operations
\item
  Datetime Support Functions
\item
  Discrete Fourier Transform (numpy.fft)
\item
  Financial functions
\item
  Functional programming
\item
  Logic functions
\item
  Mathematical functions
\item
  Matrix library (numpy.matlib)
\item
  numpy.polynomial package
\item
  具体用法和更多模块可以参考 Numpy reference 中的 Routines 内容
\end{enumerate}

\end{frame}




\end{document}


